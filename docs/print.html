<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flashcard; A tutorial</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A tutorial to create a flashcard app">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="about.html"><strong aria-hidden="true">1.</strong> What is this tutorial about</a></li><li><a href="install-elm.html"><strong aria-hidden="true">2.</strong> Installing Elm</a></li><li><a href="frontend/skeletal-elm.html"><strong aria-hidden="true">3.</strong> Skeletal Elm project</a></li><li><a href="frontend/first-flash.html"><strong aria-hidden="true">4.</strong> A first flash card</a></li><li><a href="frontend/custom-function.html"><strong aria-hidden="true">5.</strong> A custom function</a></li><li><a href="frontend/type-annotations.html"><strong aria-hidden="true">6.</strong> Type annotations</a></li><li><a href="frontend/namespaces.html"><strong aria-hidden="true">7.</strong> Namespaces</a></li><li><a href="frontend/record-type.html"><strong aria-hidden="true">8.</strong> A record type</a></li><li><a href="frontend/type-alias.html"><strong aria-hidden="true">9.</strong> Type alias</a></li><li><a href="frontend/custom-type.html"><strong aria-hidden="true">10.</strong> A custom type</a></li><li><a href="frontend/constructor.html"><strong aria-hidden="true">11.</strong> A convenient function</a></li><li><a href="frontend/let-block.html"><strong aria-hidden="true">12.</strong> Showing the back</a></li><li><a href="frontend/flip.html"><strong aria-hidden="true">13.</strong> Flip the card</a></li><li><a href="frontend/architecture.html"><strong aria-hidden="true">14.</strong> Elm Architecture</a></li><li><a href="frontend/update.html"><strong aria-hidden="true">15.</strong> Updating the model</a></li><li><a href="frontend/build.html"><strong aria-hidden="true">16.</strong> Building the frontend</a></li><li><a href="install-rust.html"><strong aria-hidden="true">17.</strong> Installing Rust</a></li><li><a href="client-directory.html"><strong aria-hidden="true">18.</strong> Creating a client directory</a></li><li><a href="backend/skeletal-rust.html"><strong aria-hidden="true">19.</strong> Skeletal Rust project</a></li><li><a href="backend/server.html"><strong aria-hidden="true">20.</strong> Simple Server</a></li><li><a href="backend/serve.html"><strong aria-hidden="true">21.</strong> Serving the frontend</a></li><li><a href="frontend/decode.html"><strong aria-hidden="true">22.</strong> Decoding a FlashCard</a></li><li><a href="frontend/test.html"><strong aria-hidden="true">23.</strong> Testing Elm</a></li><li><a href="backend/model.html"><strong aria-hidden="true">24.</strong> Model on server</a></li><li><a href="backend/serialize.html"><strong aria-hidden="true">25.</strong> Serialize FlashCard</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Flashcard; A tutorial</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-this-tutorial-about" id="what-is-this-tutorial-about">What is this tutorial about?</a></h1>
<p>In this tutorial you are going to learn how to create a flashcard app. A
flashcard is a</p>
<blockquote>
<p>card bearing information on both sides, which is intended to be used as an aid
in memorization. Each flashcard bears a question on one side and an answer on
the other. Flashcards are often used to memorize vocabulary, historical dates,
formulae or any subject matter that can be learned via a question-and-answer
format.</p>
</blockquote>
<h2><a class="header" href="#stack" id="stack">Stack</a></h2>
<p>The stack we are going to use in this tutorial is</p>
<ul>
<li><strong>frontend</strong>: <a href="https://elm-lang.org/">Elm</a></li>
<li><strong>backend</strong>: <a href="https://www.rust-lang.org/">Rust</a></li>
</ul>
<p>The reason for this eclectic mix is because it was the preference of
<a href="https://twitter.com/keinegurke_">@keinegurke_</a>. They wanted to learn both Elm, Rust and German. But an in depth
tutorial was missing. Since flashcards could help them improve their vocabulary,
they soon settle on building an app and documenting their progress in this
tutorial.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>What would you need to start with this tutorial? First of all; in interest in
either Elm, Rust, or both. The focus of this tutorial is in learning these
technologies.
Second is a computer and some experience with running commands in the
command line. Modern development relies increasingly on tools that require some
proficiency with the command line.</p>
<p>If you qualify, dive right in!</p>
<h1><a class="header" href="#installing-elm" id="installing-elm">Installing Elm</a></h1>
<p>Since <a href="https://elm-lang.org/">Elm</a> is one of the technologies we are using to create our flashcard app we
better start with installing it.</p>
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<p>How Elm can be installed is described in their <a href="https://guide.elm-lang.org/install.html">installation page</a>.
This includes setting up elm in a number of editors. Which certainly will come
in handy.</p>
<p>What is missing do are some helpful tools. Most notably <a href="https://github.com/elm-explorations/test"><code>elm-test</code></a>
and <a href="https://github.com/avh4/elm-format"><code>elm-format</code></a>.
<code>elm-test</code> is used to test your Elm code, a practice that provide even more
confidence in refactoring your code.
<code>elm-format</code> automatically formats your code, so that no wars can erupt over
where to place which comma.</p>
<p>You can learn how to <a href="https://github.com/elm-explorations/test#running-tests-locally">install <code>elm-test</code></a> from their README.
Similarly, how to <a href="https://github.com/avh4/elm-format#installation-">install <code>elm-format</code></a> is described in
their README as well.</p>
<h2><a class="header" href="#verification" id="verification">Verification</a></h2>
<p>If everything worked out as planned you should be able to execute the following
commands</p>
<pre><code class="language-sh">elm --version
</code></pre>
<p>This should respond with the latest version. At the time of writing that was
<code>0.19.0</code>.</p>
<p>Similarly, the following commands</p>
<pre><code class="language-sh">elm-test --version
</code></pre>
<p>responds at the time of writing with <code>0.19.0-rev6</code>.</p>
<p>Finally, verifying that <code>elm-format</code> is a little different. The command does not
have a <code>--version</code> flag. Instead asking for <code>--help</code></p>
<pre><code class="language-sh">elm-format --help
</code></pre>
<p>Should declare it's version at the top of its help page. Again. At the time of
this writing that was <code>0.8.1</code>.</p>
<h2><a class="header" href="#celebrate" id="celebrate">Celebrate</a></h2>
<p>You are now all set for the next chapter. But before you go and explore the
wonderful world of Elm, make sure you celebrate! Configuring your machine can be
very hard.</p>
<h1><a class="header" href="#skeletal-elm-project" id="skeletal-elm-project">Skeletal Elm project</a></h1>
<p>With all the <code>Elm</code> tools installed. It is time to take them for a spin. Right
from the Elm is a very friendly language. When you ask Elm for help</p>
<pre><code class="language-sh">elm --help
</code></pre>
<p>It will thank you for trying out Elm, give you some pointers where to find
<a href="https://guide.elm-lang.org">more information</a> and tell you about some command options. We are
interested in the <code>elm init</code> command. It promises to</p>
<blockquote>
<p>Start an Elm project. It creates a starter elm.json file and provides a link
explaining what to do from there.</p>
</blockquote>
<p>This is a nice starting point. Run the command to start an Elm project. The
skeletal project creates the following files and directories.</p>
<pre><code class="language-plain">.
├── elm.json
└── src
</code></pre>
<p>The <code>elm.json</code> describes the Elm project. We describe it in more detail later in
the tutorial. Besides the <code>elm.json</code> file there is a directory called <code>src</code>.
This is where all the source files go.</p>
<p>An empty <code>src</code> directory is an unhappy <code>src</code> directory. So let's go ahead and
create a file named <code>FlashCard.elm</code> inside the <code>src</code> directory with the
following content</p>
<pre><code class="language-elm">module FlashCard exposing (..)

import Html


main =
    Html.text &quot;Hello, World!&quot;

</code></pre>
<h2><a class="header" href="#verification-1" id="verification-1">Verification</a></h2>
<p>One of the cool things about Elm is that it can serve your files. By spinning up
a reactor Elm will look at your files, create a web server, serve your files and
when necessary compile them on the fly.</p>
<pre><code class="language-sh">elm reactor
</code></pre>
<p>The above command will start the Elm reactor. The message that it returns with
asks you to got to <a href="http://localhost:8000">http://localhost:8000</a>. Going to that
address you will find a file navigation pane. Navigate it to <code>src</code> &gt;
<code>FlashCard.elm</code> and be greeting by your very own <code>Hello, World!</code></p>
<h1><a class="header" href="#a-first-flash-card" id="a-first-flash-card">A first flash card</a></h1>
<p>Let's focus on how the structure of the Html should look like. In order to use
the capabilities of Elm way of doing Html we imported the <code>Html</code>
<a href="https://guide.elm-lang.org/webapps/modules.html"><em>module</em></a>.</p>
<pre><code class="language-elm">import Html
</code></pre>
<p>A <em>module</em></p>
<blockquote>
<p>let you break your code into multiple files</p>
</blockquote>
<p>You can define you own modules, but we will wait until the opportunity arises.
First we will be using modules defined in <em>packages</em> as found on <a href="https://package.elm-lang.org/">Elm packages</a></p>
<h2><a class="header" href="#html-module" id="html-module"><code>Html</code> module</a></h2>
<p>The <code>Html</code> module has <a href="https://package.elm-lang.org/packages/elm/html/latest/">documentation</a> as found in the Elm packages. It needs a
little getting used to, but eventually you will get the hang of it.</p>
<p>If we would write plain Html that would display a flash card, we could write
something like this</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;span&gt;Wettervorhersage&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>Note that <em>wettervorhersage</em> is a German word meaning <em>weather forecast</em>. Maybe
the snippet of Html is missing some attributes and classes, but for now we will
focus on the structure.</p>
<p>To mimick the snippet in Elm, we would write the following code in elm</p>
<pre><code class="language-elm">main =
    Html.div []
        [ Html.span [] [ Html.text &quot;Wettervorhersage&quot; ]
        ]
</code></pre>
<p>There are several things going on here. Not that Elm is a <a href="https://en.wikipedia.org/wiki/Functional_programming"><em>functional
language</em></a>. This means that functions are the building blocks of
creating programs.</p>
<p>There are three functions used to recreate the Html. <code>Html.div</code>, <code>Html.span</code> and
<code>Html.text</code>. Almost all functions in the Html module that produce tags accept
two arguments. A list of attributes, and a list of content.</p>
<p>We haven't defined attributes yet so the first argument of <code>Html.div</code> and
<code>Html.span</code> is the <em>empty list</em>: <code>[]</code>. The second argument of <code>Html.div</code> is a
list with content, i.e. a span that itself contains text.</p>
<p>We will have more to say about functions but for now we can verify that
everything works as expected.</p>
<h2><a class="header" href="#verification-2" id="verification-2">Verification</a></h2>
<p>When you reload the flash card app in the browser, you should see the German
word for weather forecast.</p>
<h1><a class="header" href="#a-custom-function" id="a-custom-function">A custom function</a></h1>
<p>We have created our first flash card, but it can only show &quot;Wettervorhersage&quot;.
Although it is a great word, we would like to be able to show different words.
Let's make that possible with the introduction of a custom function.</p>
<p>What we would like to achieve is to write</p>
<pre><code class="language-elm">main =
    view &quot;Wettervorhersage&quot;
</code></pre>
<p>and let the <code>view</code> function return the Html for the flash card. For this we need
to create a function. Functions are defined by stating their name, i.e. <code>view</code>,
and their arguments. For us that would be the text that we want to show, so
let's call the argument for our function <code>text</code>.</p>
<p>Next would comes the body of the function and it defined the return value. For
us that looks very similar to our first flash card. The only difference is that
instead of the hard coded <code>&quot;Wettervorhersage&quot;</code>, we want to show the argument,
I.e. <code>text</code>.</p>
<p>Putting all this together, the <code>view</code> function comes down together</p>
<pre><code class="language-elm">view text =
    Html.div []
        [ Html.span [] [ Html.text text ]
        ]
</code></pre>
<h2><a class="header" href="#verification-3" id="verification-3">Verification</a></h2>
<p>If your reload the application you should still see our flash card that displays
&quot;Wettervorhersage&quot;. Changing the argument of the view function and reloading
should reflect in the app.</p>
<h1><a class="header" href="#type-annotations" id="type-annotations">Type annotations</a></h1>
<p>We have just created a custom function. It is lacking one of the Elm strongest
features. I.e. <a href="https://en.wikipedia.org/wiki/Data_type"><em>type information</em></a>.</p>
<p>Types help a compiler to determine if programs are correct. They can be used to
verify that the expectations you have about functions and programs are met, even
before the program is run.</p>
<p>Up until now, Elm has <em>inferred</em> the types of our functions. But relying on the
type inference could hide some problems. So let's annotate our <code>view</code> function
with it's type.</p>
<h2><a class="header" href="#common-types" id="common-types">Common types</a></h2>
<p>Elm has some built in types that you can use right out of the gate. One that we
already have used is <a href="https://package.elm-lang.org/packages/elm/core/latest/String"><code>String</code></a>. It is a chunk of text. Elm also
provides a myriad of functions for <code>String</code> but now we are only interested in
it's type.</p>
<p>Remember that Elm is a <a href="https://en.wikipedia.org/wiki/Functional_programming">functional language</a>? Because functions are
so important you can provide type information for them as well. This is done
with an arrow <code>-&gt;</code>.</p>
<p>On the left side of the arrow you place the type of the argument of the
function. To the right of the arrow you place the type of the return value. But
what is that? Let's guess it to by <code>String</code> and see what Elm makes of it.</p>
<p>Providing type information for the <code>view</code> function is done by</p>
<pre><code class="language-elm">view : String -&gt; String
</code></pre>
<p>This is placed right above the definition of the <code>view</code> function.</p>
<h2><a class="header" href="#verification-4" id="verification-4">Verification</a></h2>
<p>If you reload the application you will be greated by a friendly message from the
Elm compiler</p>
<blockquote>
<p>-- TYPE MISMATCH --------------------------------------------- src/FlashCard.elm</p>
<p>Something is off with the body of the <code>view</code> definition:</p>
<p>11|&gt;    Html.div []
12|&gt;        [ Html.span [] [ Html.text text ]
13|&gt;        ]</p>
<p>This <code>div</code> call produces:</p>
<pre><code>Html.Html msg
</code></pre>
<p>But the type annotation on <code>view</code> says it should be:</p>
<pre><code>String
</code></pre>
</blockquote>
<p>We guessed the return type for the <code>view</code> function to be <code>String</code>. But that is not
correct. Elm noticed that the type difference from what actually is returned.
Let's change the type signature of the <code>view</code> function to</p>
<pre><code class="language-elm">view : String -&gt; Html.Html ()
</code></pre>
<p>for now. We will go into the convoluted <code>Html.Html ()</code> later.</p>
<p>Once you reload the application again. You should be greeted by &quot;Wettervorhersage&quot;.</p>
<h1><a class="header" href="#namespaces" id="namespaces">Namespaces</a></h1>
<p>We have just specified the return type of the <code>view</code> function to be 
<code>Html.Html ()</code>. Why are there two mentions of <code>Html</code>? We will answer that
question in this chapter.</p>
<p>Look at the top of the file. There is an import line.</p>
<pre><code class="language-elm">import Html
</code></pre>
<p>This imports the <a href="https://package.elm-lang.org/packages/elm/html/latest/"><code>Html</code> module</a> from the <code>Htmll</code> package. As can be
seen from the documentation, this package provides a lot of useful functions.
In order to use these functions you have to use there fully qualified name. E.g.
if you want to use the function <code>div</code> that will render a div element on the
page. You write</p>
<pre><code class="language-elm">Html.div
</code></pre>
<p>The reason for using the fully qualified name is to avoid <em>name clashes</em>. Let's
illustrate a name clash with an example.</p>
<h2><a class="header" href="#favorite-number" id="favorite-number">Favorite number</a></h2>
<p>We are going to ask somebody to create a module providing us with their
favorite number. Kirsty told us that her favorite number is <code>42</code>. Daan favorite
on the other hand is 37. We could create modules that record these favorites.</p>
<p>We will settle on the name <code>number</code> to record the respective favorite number. If
we wanted to use both numbers in one program, we would not have a problem. We
can use fully qualify the name and we would still know which number we mean.</p>
<p>If we wanted to use Kirsty's number we would write <code>Kirsty.number</code> and get 42.
If instead we wanted to use Daan's number, we would wirte <code>Daan.number</code>.</p>
<h2><a class="header" href="#second-html" id="second-html">Second <code>Html</code></a></h2>
<p>We learned about the first <code>Html</code> in the signature of the <code>view</code> function. It is
the Html <em>namespace</em>. A namespace will prevent name clashes between different
modules. But what about the second <code>Html</code>.</p>
<p>If you take a look at the <a href="https://package.elm-lang.org/packages/elm/html/latest/"><code>Html</code> documentation</a> you will find it
exposes a type alias <a href="https://package.elm-lang.org/packages/elm/html/latest/Html#Html"><code>Html</code></a>. The <code>Html</code> type can be used to annotate
functions like our <code>view</code> function that it is returning Html.</p>
<h2><a class="header" href="#exposing-names" id="exposing-names">Exposing names</a></h2>
<p>Sometimes there is no danger of name clashes. E.g. it will be unlikely that we
will using two <code>Html</code> types. In order to shorten the <code>Html.Html</code> part to just
the type <code>Html</code> we can expose the <code>Html</code> type into our own namespace.</p>
<p>We can expose names from modules when we import them. In order to expose the
<code>Html</code> type from the <code>Html</code> module we would write</p>
<pre><code class="language-elm">import Html exposing (Html)
</code></pre>
<p>This allows us to write the signature of the view function ascii</p>
<pre><code class="language-elm">view : String -&gt; Html ()
</code></pre>
<p>If you find it tedious to have to fully qualify the <code>div</code> and <code>span</code> functions
from the <code>Html</code> module. the import line would read</p>
<pre><code class="language-elm">import Html exposing (Html, div, span)
</code></pre>
<h2><a class="header" href="#verification-5" id="verification-5">Verification</a></h2>
<p>In this chapter you learned about namespaces, fully qualified names and
exposing names in your own namespace. In order to verify if you have grasped
these concept, try to answer the following question.</p>
<p>Why can't we expose the <code>text</code> function from the <code>Html</code> module?</p>
<h1><a class="header" href="#a-record-type" id="a-record-type">A record type</a></h1>
<p>We annotated our <code>view</code> function with it's type, but something does not feel
right. Shouldn't a flash card have a front and a back? Just a single <code>String</code>
does not cut it.</p>
<p>Let's remedy this with a <a href="https://guide.elm-lang.org/core_language.html">record</a>.</p>
<h2><a class="header" href="#records" id="records">Records</a></h2>
<p>A record</p>
<blockquote>
<p>can hold many values, and each value is associated with a name.</p>
</blockquote>
<p>Our flash card has a front and a back, so describe the flash card type with
record seems a nice fit.</p>
<p>Instead of accepting a <code>String</code> as the argument to our <code>view</code> function, we
should accept a record that has a <code>front</code> and a <code>back</code>.</p>
<pre><code class="language-elm">view : { front : String, back : String } -&gt; Html ()
</code></pre>
<p>Now the argument name of <code>text</code> isn't very well chosen anymore. Lets change it
to <code>card</code>.</p>
<pre><code class="language-elm">view card =
   ...
</code></pre>
<p>Since we renamed the argument from <code>text</code> to <code>card</code>, we can't use <code>text</code> in the
body of the function anymore. Let's replace it with the front of the card</p>
<pre><code class="language-elm">    div []
        [ span [] [ Html.text card.front ]
        ]
</code></pre>
<p>We now introduced a new type; a record with a <code>front</code> and a <code>back</code>, both of type
<code>String</code>. But we haven't changed to argument we are calling the <code>view</code> function
with.</p>
<pre><code class="language-elm">main =
    view { front = &quot;Wettervorhersage&quot;, back = &quot;Weather forecast&quot; }
</code></pre>
<h2><a class="header" href="#verification-6" id="verification-6">Verification</a></h2>
<p>If you reload the web app once more. You should still see &quot;Wettervorhersage&quot;.</p>
<h1><a class="header" href="#type-alias" id="type-alias">Type alias</a></h1>
<p>Our flash card type now is <code>{ front : String, back : String }</code> which, to say the
least, does not roll off the tongue easily. Instead we would like to name our
flash card type <code>FlashCard</code>.</p>
<p>This can be achieved with a <em>type alias</em>. A type alias will introduce a name
for a different type. This has several benefits. Among them it allows you to
have a recognizable name for a type.</p>
<p>If you want to introduce a type alias you use the <code>type alias</code> keywords. In our
case you could use it like</p>
<pre><code class="language-elm">type alias FlashCard =
    { front : String, back : String }
</code></pre>
<p>With the type alias introduced we can clean up the signature of the <code>view</code>
function by changing it to</p>
<pre><code class="language-elm">view : FlashCard -&gt; Html ()
</code></pre>
<h2><a class="header" href="#verification-7" id="verification-7">Verification</a></h2>
<p>Fundamentally, nothing changed to the program, we only introduced a name for a
familiar thing. The application should still show &quot;Wettervorhersage&quot; when
reloaded.</p>
<h1><a class="header" href="#a-custom-type" id="a-custom-type">A custom type</a></h1>
<p>We have created a fuller flash card. It has a front and a back. But what way is
it facing? Are we seeing the front or the back?</p>
<p>If we want to differentiate we should be able to express the difference. We will
do that with a custom type.</p>
<h2><a class="header" href="#face" id="face">Face</a></h2>
<p>The following code introduces a new type <code>Face</code>. It will be used to determine
which way our flashcard is facing.</p>
<pre><code class="language-elm">type Face
    = Front
    | Back
</code></pre>
<p>The <code>type</code> construct is an example of an <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data type</em></a>. That is a
fancy name saying that there are certain ways of combining different types into
more complex types. We will come back to that subject later on.</p>
<h2><a class="header" href="#extending-flashcard" id="extending-flashcard">Extending <code>FlashCard</code></a></h2>
<p>With a <code>Face</code> we should extend our <code>FlashCard</code> model. In the <code>FlashCard</code> type
alias add a field <code>face</code> of type <code>Face</code>.</p>
<pre><code class="language-elm">type alias FlashCard =
    { front : String
    , back : String
    , face : Face
    }
</code></pre>
<p>This will break our program. This is because when we created a flash card we
should also specify which way it is facing.</p>
<pre><code class="language-elm">{ front = &quot;Wettervorhersage&quot;, back = &quot;Weather forecast&quot;, face = Front }
</code></pre>
<h2><a class="header" href="#verification-8" id="verification-8">Verification</a></h2>
<p>If it compiles, it should still show you &quot;Wettervorhersage&quot; when you reload the
app. </p>
<h1><a class="header" href="#a-convenient-function" id="a-convenient-function">A convenient function</a></h1>
<p>If we want to create a flash card we have to write</p>
<pre><code class="language-elm">{ front = &quot;Wettervorhersage&quot;, back = &quot;Weather forecast&quot;, face = Front }
</code></pre>
<p>That is a whooping 71 characters. Most of these characters are boilerplate.
Can't we do better than that?</p>
<h2><a class="header" href="#functions-to-the-rescue" id="functions-to-the-rescue">Functions to the rescue</a></h2>
<p>Of course we can do better. We can create a function that helps us with creating
a flash card.</p>
<p>Let's think about a name for the function. It creates a flash card so
<code>flash_card</code> seems appropriate.</p>
<p>Having settled on the name let's think about the signature. We would create
flash cards facing <code>Front</code>. So the only parts that are moving are the front and
the back.
This means our functions needs to accept two <code>String</code>s and returns a
<code>FlashCard</code>. The way the describe that in Elm is</p>
<pre><code class="language-elm">flash_card : String -&gt; String -&gt; FlashCard
</code></pre>
<p>It needs some getting used to, but there are good reasons why the signature
looks the way it does.</p>
<p>With the signature in place, we can go on to defining the function.</p>
<pre><code class="language-elm">flash_card front back =
    { front = front, back = back, face = Front }
</code></pre>
<h2><a class="header" href="#verification-9" id="verification-9">Verification</a></h2>
<p>We can now use the <code>flash_card</code> function. We do need some parenthesis, or else
Elm will get confused.</p>
<pre><code class="language-elm">`main =
    view (flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;)
</code></pre>
<p>Other than that, everything should still work. As an other verification: what if
we wanted to pass which way the flash card is facing to our <code>flash_card</code>
function, how would the signature change?</p>
<h1><a class="header" href="#showing-the-back" id="showing-the-back">Showing the back</a></h1>
<p>We have been staring at Wettervorhersage for a while now. We would like to
convince ourselves that we still know it's translation. Time to leverage the
<code>face</code> of our <code>FlashCard</code> and show a different side.</p>
<h2><a class="header" href="#let-expression" id="let-expression">Let expression</a></h2>
<p>In our view function we hard-coded to show the front of the flash card.</p>
<pre><code class="language-elm">view card =
    div []
        [ span [] [ Html.text card.front ]
        ]
</code></pre>
<p>We like to be able to change which text we show depending on the face that is
showing. For this we are going to introduce a <a href="https://elm-lang.org/docs/syntax#let-expressions"><code>let</code>-expression</a> in our
<code>view</code> function.</p>
<p>A <code>let</code> expression is useful when</p>
<blockquote>
<p>when an expression is getting large. You can make a let to break it into
smaller definitions and put them all together in a smaller expression. </p>
</blockquote>
<p>We first use it to introduce a name for the text we want to show.</p>
<pre><code class="language-elm">view card =
    let
        text = card.front
     div []
        [ span [] [ Html.text text ]
        ]

</code></pre>
<p>In it self this isn't a big change. It only allows us to define a name. But the
value we bind this name is now under our control.</p>
<h2><a class="header" href="#showing-the-back-1" id="showing-the-back-1">Showing the back</a></h2>
<p>We would like to show the a different text when we face the back.We can achieve
that by matching on the flash cards face.</p>
<pre><code class="language-elm">text =
    case card.face of
        Front -&gt;
            card.front

        Back -&gt;
            card.back
</code></pre>
<p>this makes use of new concept: <a href="https://guide.elm-lang.org/types/pattern_matching.html">Pattern matching</a>. A <code>case</code> expression</p>
<blockquote>
<p>allows us to branch based on which variant we happen to see.</p>
</blockquote>
<p>So if our card faces <code>Front</code> we want our card to show the <code>card.front</code>. And when
it faces <code>Back</code> we want to see <code>card.back</code>.</p>
<h2><a class="header" href="#verification-10" id="verification-10">Verification</a></h2>
<p>Make a prediction what would happen when you reload the web application. If your
prediction matches the reality you probably know what is up next.</p>
<h1><a class="header" href="#flip-the-card" id="flip-the-card">Flip the card</a></h1>
<p>When we reloaded the application we still saw Wettervorhersage. The reason for
this is that the model we are viewing hasn't changed. In order to see something
different we need to flip the card.</p>
<h2><a class="header" href="#a-flip-function" id="a-flip-function">A <code>flip</code> function</a></h2>
<p>Let's create a function that will do the flipping for us. We start by thinking
about the signature, i.e. what goes in the function and what should come out.
Since we want to flip a <code>FlashCard</code> picking that as a argument to our function
makes sense. The result should be a <code>FlashCard</code> again. So our <code>flip</code> function
has a signature of</p>
<pre><code class="language-elm">flip: FlashCard -&gt; FlashCard
</code></pre>
<p>When we start thinking of the implementation we quickly run into the problem of
determining the opposite of a face. I.e. when we are facing <code>Front</code> the opposite
should be <code>Back</code> and vice versa.</p>
<p>Let's cater to that now and so that we can use that function in the definition
of <code>flip</code>.</p>
<h2><a class="header" href="#an-opposite-function" id="an-opposite-function">An <code>opposite</code> function</a></h2>
<p>Again, we start thinking of the signature of our function. In should go a <code>Face</code>
and out should come a <code>Face</code> again.</p>
<pre><code class="language-elm">opposite: Face -&gt; Face
</code></pre>
<p>We just learned about the <code>let</code>-expression, which comes in handy now. Because it
allows us to determine which value occurs so we can take action accordingly.</p>
<pre><code class="language-elm">opposite : Face -&gt; Face
opposite face =
    case face of
        Front -&gt;
            Back

        Back -&gt;
            Front
</code></pre>
<h2><a class="header" href="#flip-reloaded" id="flip-reloaded"><code>flip</code> reloaded</a></h2>
<p>With a new brush in our art kit we are able to continue our implementation of
<code>flip</code>. We should return a <code>FlashCard</code> with the same front and back as our
input, but with the opposite face.</p>
<pre><code class="language-elm">flip card =
    { front = card.front, back = card.back , face = opposite card.face }
</code></pre>
<p>Pfew, that was a lot of typing. Isn't there a better way? I certainly would not
want to type all those fields if our model grows.</p>
<h2><a class="header" href="#flip-revolutions" id="flip-revolutions"><code>flip</code> revolutions</a></h2>
<p>Luckily Elm allows that. It basically allows us to say; take this flashcard and
only modify the fields we are interested in. The syntax is shown below and is
exactly similar to the code above.</p>
<pre><code class="language-elm">flip card =
    { card | face = opposite card.face }
</code></pre>
<p>Sweet!</p>
<h2><a class="header" href="#verification-11" id="verification-11">Verification</a></h2>
<p>We have a <code>flip</code> function, but we need to use it. </p>
<pre><code class="language-elm">main =
    view (flip (flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;))
</code></pre>
<p>Reloading the web application now will show &quot;Weather forecast&quot;, but at a cost of
a lot of parenthesis. Elm has a way to form a <a href="https://elm-lang.org/docs/syntax#operators">pipeline</a>. Below you can see
how it works.</p>
<pre><code class="language-elm">main =
    flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;
        |&gt; flip
        |&gt; view
</code></pre>
<p>Here we first create a flash card with the <code>flash_card</code> function. We pass that
flash card to the <code>flip</code> function via the <code>|&gt;</code> operator. The result of the flip
function is in its turn passed to the <code>view</code> function via the same <code>|&gt;</code>
operator.</p>
<p>We will take a closer look at the <code>|&gt;</code> operator and other functions.</p>
<h1><a class="header" href="#elm-architecture" id="elm-architecture">Elm Architecture</a></h1>
<p>We are capable to flip a card, but we want to control when we flip it. At the
moment we are only generating static content. How does Elm allow values to
change.</p>
<p>In this chapter we will look into the <em>Elm architecture</em>.</p>
<h2><a class="header" href="#model-view-update" id="model-view-update">Model-View-Update</a></h2>
<p>The <a href="https://guide.elm-lang.org/architecture/">Elm architecture</a> is a pattern that help in structuring
an interactive application.</p>
<p>It revolves around a Model, a View and a way to Update the model. Two of the
parts are in place already. Our model is a <code>FlashCard</code> with <code>view</code> as it's View
function.</p>
<p>What is missing is the Update function and how it interacts with Elm.</p>
<h2><a class="header" href="#pure-functions" id="pure-functions">Pure functions</a></h2>
<p>Functions in Elm are <em>pure</em>. A pure function is</p>
<blockquote>
<p>a function that has the following properties:</p>
<ol>
<li>Its return value is the same for the same arguments (no variation with
local static variables, non-local variables, mutable reference arguments or
input streams from I/O devices). </li>
<li>Its evaluation has no side effects (no mutation of local static variables,
non-local variables, mutable reference arguments or I/O streams).</li>
</ol>
</blockquote>
<p>This property has some nice benefits. But how do we change things, if functions
should always return the same on the same input?</p>
<h2><a class="header" href="#elm-runtime" id="elm-runtime">Elm runtime</a></h2>
<p>The Elm runtime is the escape hatch that allows change in our web app. The
runtime is responsible for the Model. It will use a View function to show our
application. It will Update the model in the way we tell it to.</p>
<p>The way we tell it to is by sending a Message. This Message allows the Update
function to differentiate how to update the model.</p>
<p>We will be sending Message from the application, e.g. by clicking a button.</p>
<p>This probably all sounds very abstract. It will become clear in the next
chapter. Note that every Elm application is structured, even recursively, with
the Elm architecture. This helps developers in managing their code base.</p>
<h1><a class="header" href="#updating-the-model" id="updating-the-model">Updating the model</a></h1>
<p>Let's work on applying the Elm architecture and update the model.</p>
<h2><a class="header" href="#message" id="message">Message</a></h2>
<p>We first start to think about the message our model understands. At the moment
we are only interested in flipping a card. A good message would be <code>Flip</code>. Let's
start from there</p>
<pre><code class="language-elm">type Message
    = Flip
</code></pre>
<p>Now we created the ability to express the fact that we want to change our model.</p>
<h2><a class="header" href="#model" id="model">Model</a></h2>
<p>We keep talking about our model. We know that it is a flash card, but that could
change in the future. Aligning our code with the Elm way has some benefits. So
let's introduce an alias.</p>
<pre><code class="language-elm">type alias Model =
    FlashCard
</code></pre>
<p>This way we can talk about <code>Model</code> in our signatures and it will align with Elm,
but we haven't lost the ability to address is as a <code>FlashCard</code>.</p>
<h2><a class="header" href="#update" id="update">Update</a></h2>
<p>Let's create an <code>update</code> function. The signature of the update model is
determined by Elm. It should benefits</p>
<pre><code class="language-elm">update : Message -&gt; Model -&gt; Model
</code></pre>
<p>We give it a <code>Message</code> and a <code>Model</code>. Update will return a <code>Model</code> depending on
the two. The implementation is straight forward, since there is only one
instance of the <code>Message</code> type.</p>
<pre><code class="language-elm">update message model =
    case message of
        Flip -&gt;
            flip model
</code></pre>
<p>Match on the message, and for each case, even when there is only one, determine
what to do. The <code>flip</code> function is what we need in the <code>Flip</code> case.</p>
<h2><a class="header" href="#wire-it-all-together" id="wire-it-all-together">Wire it all together</a></h2>
<p>Now we need to tell Elm how these parts work together. There is a 
<a href="https://package.elm-lang.org/packages/elm/browser/latest/"><code>Browser</code> module</a> that offers different programs. We will be
interested in <code>sandbox</code>.</p>
<p>In order to be able to use the <code>Browser</code> module we need to import it.</p>
<pre><code class="language-elm">import Browser
</code></pre>
<p>The sandbox needs a structure with the following fields</p>
<ul>
<li><code>init</code>. The initial model.</li>
<li><code>view</code>. The view function used to display the model.</li>
<li><code>update</code>. an finally the update function used.</li>
</ul>
<p>We all have those in place. So we can</p>
<h2><a class="header" href="#verification-12" id="verification-12">Verification</a></h2>
<p>Change the <code>main</code> variable to</p>
<pre><code class="language-elm">main =
    let
        model =
            flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;
    in
    Browser.sandbox
        { init = model
        , view = view
        , update = update
        }
</code></pre>
<p>And now we can finally flip the flash card.</p>
<h1><a class="header" href="#building-the-frontend" id="building-the-frontend">Building the frontend</a></h1>
<p>A browser can not execute Elm. We first must make our Elm code into a form that
the browser will understand.</p>
<p>Luckily the <code>elm</code> command knows how to do that.</p>
<h2><a class="header" href="#elm-make" id="elm-make"><code>elm</code> make</a></h2>
<p>There is a sub-command that is able to create files that the browser knows
about. It is called <code>elm make</code>. Running <code>elm make --help</code> show </p>
<pre><code class="language-plain">The `make` command compiles Elm code into JS or HTML:

    elm make &lt;zero-or-more-elm-files&gt;

For example:

    elm make src/Main.elm

This tries to compile an Elm file named src/Main.elm, putting the resulting
JavaScript code in an elm.js file.
</code></pre>
<p>We left out the flags that can be passed to this sub command.</p>
<p>Let's use the sub command to make an <code>index.html</code>. This way we don't need to
reactor to show our app.</p>
<pre><code class="language-sh">elm make src/FlashCard.elm
</code></pre>
<p>The command above should create an <code>index.html</code> in the current work directory.</p>
<h2><a class="header" href="#verification-13" id="verification-13">Verification</a></h2>
<p>Open the just generated <code>index.html</code> with a browser, and check that
Wettervorhersage still means Weather forecast.</p>
<h1><a class="header" href="#installing-rust" id="installing-rust">Installing Rust</a></h1>
<p>We will use <a href="https://www.rust-lang.org/">Rust</a> to create a web server. Before we can start writing our
web server, we should install Rust.</p>
<h2><a class="header" href="#installation-1" id="installation-1">Installation</a></h2>
<p>Rust can be installed and updated via a handy tool called <code>rustup</code> as described
on the <a href="https://www.rust-lang.org/tools/install">installation page</a>. This allows
you to have multiple different versions of Rust live next to each other.</p>
<p>When you execute the installation command, the install script will asks some
questions. Make sure you read and understand what the script will try to
achieve. For this tutorial no customization is necessary.</p>
<p>When the scripts finished Rust is installed. This comes with a couple of tools.</p>
<h2><a class="header" href="#verification-14" id="verification-14">Verification</a></h2>
<p>To make sure that the installation was successful the following commands should
run without error.</p>
<pre><code class="language-sh">cargo --version
</code></pre>
<p>The above command should respond with the installed cargo version. At the time
of this writing that was <code>1.38.0</code>.</p>
<pre><code class="language-sh">rustc --version
</code></pre>
<p>Should respond with the same version.</p>
<h1><a class="header" href="#creating-a-client-directory" id="creating-a-client-directory">Creating a client directory</a></h1>
<p>What we have been working on up until now is the client for our application.
With Rust installed, we quickly will move into writing server code. We better
setup our project source tree to reflect our intentions.</p>
<p>This entails little more than to creating a <code>client</code> directory and moving our
stuff over there.</p>
<h2><a class="header" href="#verification-15" id="verification-15">Verification</a></h2>
<p>Make sure that running the Elm reactor, or building the frontend still works as
expected.</p>
<h1><a class="header" href="#skeletal-rust-project" id="skeletal-rust-project">Skeletal Rust project</a></h1>
<p>We used our frontend tooling to create a skeletal project for us. Just like with
our frontend, our backend tooling allows us to do the same.</p>
<h2><a class="header" href="#cargo-new" id="cargo-new">cargo new</a></h2>
<p>The <code>cargo</code> command is the go to place for Rust development.</p>
<pre><code class="language-sh">cargo --help
</code></pre>
<p>Shows all sort of sub-commands available. The one we are interested in is the
<code>cargo new</code> command.</p>
<pre><code>cargo new --help
</code></pre>
<p>shows use</p>
<blockquote>
<p>Create a new cargo package at <path></p>
</blockquote>
<p>It has some options that we are going to use. The following command</p>
<pre><code class="language-plain">cargo new --bin --name 'flashcard-server' server 
</code></pre>
<p>will produce the structure below.</p>
<pre><code class="language-plain">server
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>The <code>Cargo.toml</code> files describes the project and there already is a <code>main.rs</code>
source file scaffold.</p>
<h2><a class="header" href="#verification-16" id="verification-16">Verification</a></h2>
<p>Go into the <code>server</code> directory and run the</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>command. This will compile your sources and greet you with a friendly <code>Hello, world!</code>.</p>
<h1><a class="header" href="#simple-server" id="simple-server">Simple Server</a></h1>
<p>In this chapter we are going to create a simple server. Our goal is to make it
greet us when we make a request.</p>
<h2><a class="header" href="#gotham" id="gotham">Gotham</a></h2>
<p>We will be leveraging the Rust eco-system instead of reinventing the wheel our
self. There are a lot of packages available to us. They live at <a href="https://crates.io/">crates.io</a>.
One of the packages we will be using is Gotham.</p>
<p><a href="https://gotham.rs/">Gotham</a> is a</p>
<blockquote>
<p>flexible web framework that promotes stability, safety, security and speed.</p>
</blockquote>
<h2><a class="header" href="#add-dependency" id="add-dependency">Add dependency</a></h2>
<p>Before we can use a package we need to declare it as a dependency. This is done
in the <code>Cargo.toml</code>. We need to add our dependency to the <code>dependencies</code> table.</p>
<pre><code class="language-toml">[dependencies]
gotham = &quot;0.4.0&quot;
</code></pre>
<h2><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h2>
<p>Next we will create a minimal server that responds with <code>Hello, world!</code> with
every request.</p>
<p>Change <code>main.rs</code> with</p>
<pre><pre class="playpen"><code class="language-rust">extern crate gotham;

use gotham::state::State;

const HELLO_WORLD: &amp;'static str = &quot;Hello World!&quot;;

pub fn say_hello(state: State) -&gt; (State, &amp;'static str) {
    (state, HELLO_WORLD)
}

pub fn main() {
    let addr = &quot;localhost:8886&quot;;
    println!(&quot;Listening for requests at http://{}&quot;, addr);
    gotham::start(addr, || Ok(say_hello))
}
</code></pre></pre>
<p>This is taken from the hello-world example from the Gotham page.</p>
<h2><a class="header" href="#verification-17" id="verification-17">Verification</a></h2>
<p>Run the server with the command</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>This will compile <code>main.rs</code> and the transitive dependencies. This can take some
time. When it finishes it announces</p>
<pre><code class="language-plain">Listening for requests at http://localhost:8886
</code></pre>
<p>Now open a browser and navigate to
<a href="http://localhost:8886"><code>http://localhost:8886</code></a> and you will be greeted with an
<code>Hello, world!</code>.</p>
<h1><a class="header" href="#serving-the-frontend" id="serving-the-frontend">Serving the frontend</a></h1>
<p>Wouldn't it be interesting to serve the frontend from our server? Let's work on
that in this chapter.</p>
<p>For this it is best to have an <code>assets</code> directory that will hold all of our
static assets. In the server directory create an <code>assets</code> directory and move the
<code>index.html</code> to it.</p>
<pre><code class="language-plain">assets/
└── index.html
</code></pre>
<h2><a class="header" href="#serving-static-files" id="serving-static-files">Serving static files</a></h2>
<p>Gotham allows us to define a <em>router</em>. A router allows you to control which
handlers get to handle certain requests. In order to use it we need some
imports.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use gotham::router::builder::{build_simple_router, DefineSingleRoute, DrawRoutes};
#}</code></pre></pre>
<p>We don't need the <code>HELLO_WORLD</code>, or <code>say_hello</code>, so we can get rid of it.
Instead we will define the router to serve our <code>index.html</code>. We use the 
<code>build_simple_router</code> factory for that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let router = build_simple_router(|route|{
    route.get(&quot;/&quot;).to_file(&quot;assets/index.html&quot;);
});
#}</code></pre></pre>
<p>The <code>build_simple_router</code> accepts a <em>closure</em> that enables us to configure the
routes. We want to respond with <code>index.html</code> when we make a get request.</p>
<h2><a class="header" href="#server-with-routes" id="server-with-routes">Server with routes</a></h2>
<p>We now need to start the server with our router.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
gotham::start(addr, router);
#}</code></pre></pre>
<h2><a class="header" href="#verification-18" id="verification-18">Verification</a></h2>
<p>Restart the server by shutting it down and running <code>cargo run</code> again. This will
recompile the server and start waiting for requests. Open your browser and open
the application. It should serve the frontend application.</p>
<h1><a class="header" href="#decoding-a-flashcard" id="decoding-a-flashcard">Decoding a FlashCard</a></h1>
<p>We would like the let the server decide which flash card to show. In order for
that to work, we need to be able to receive JSON data and decode that into a
<code>FlashCard</code>.</p>
<p>This chapter we will be working on that.</p>
<h2><a class="header" href="#json-package" id="json-package">json package</a></h2>
<p>There is a <a href="https://package.elm-lang.org/packages/elm/json/latest/"><code>json</code> package</a> that will help us decode, and encode, JSON
into datatypes that we are interested in. Before we can use it we need to
install it.</p>
<pre><code class="language-sh">elm install elm/json
</code></pre>
<h2><a class="header" href="#jsondecode" id="jsondecode"><code>Json.Decode</code></a></h2>
<p>We will be using the <code>Json.Decode</code> module from the <code>json</code> package. Because we
want to avoid typing <code>Json.Decode</code> everywhere when we want to refer to a type
from that module, we are importing it with a different name.</p>
<p>Since we will be defining a <code>Decoder</code> we will expose that type into our
name space. </p>
<pre><code class="language-elm">import Json.Decode as Decode exposing (Decoder)
</code></pre>
<h2><a class="header" href="#decoder" id="decoder"><code>Decoder</code></a></h2>
<p>We want a <code>Decoder</code> for <code>FlashCard</code>. The type therefore should be</p>
<pre><code class="language-elm">decode : Decoder FlashCard
</code></pre>
<p>Decoders work by composing primitive decoders into more elaborate once.
Primitive decoders include</p>
<ul>
<li><code>Decode.string</code> that will decode a string value.</li>
<li><code>Decode.int</code> that will decode an int value.</li>
<li><code>Decode.bool</code> that will, well you can probably guess what type of value it
decodes.</li>
</ul>
<p>More elaborate decoders are for example <code>Decode.map</code> or variants. It's signature
is </p>
<pre><code class="language-elm">Decode.map : (one -&gt; other) -&gt; Decoder one -&gt; Decoder other
</code></pre>
<p>It takes a function that maps one type into the other, a decoder for one and
will produce a decoder for other. Under the cover the one decoder is used and
when successful the transformation is applied to the result.</p>
<h2><a class="header" href="#json" id="json">JSON</a></h2>
<p>Below we will give an example of the JSON we expect to receive. It probably does
not surprise you that it looks like</p>
<pre><code class="language-json">{ &quot;front&quot;: &quot;Wettervorhersage&quot;, &quot;back&quot;: &quot;Weather forecast&quot;, &quot;face&quot;: &quot;Front&quot; }
</code></pre>
<h2><a class="header" href="#decoder-flashcard" id="decoder-flashcard">Decoder FlashCard</a></h2>
<p>We will create a decoder that will ignore the face field of the JSON. When we
have a little more experience we will come back and decode that as well. That
means that the decoder becomes</p>
<pre><code class="language-elm">decode : Decoder FlashCard
decode =
    Decode.map3 FlashCard
        (Decode.field &quot;front&quot; Decode.string)
        (Decode.field &quot;back&quot; Decode.string)
        (Decode.field &quot;face&quot; &lt;| Decode.succeed Front)
</code></pre>
<p>We use <code>Decode.map3</code> and the <code>FlashCard</code> constructor, which got automatically
created when we introduced the type alias, to map three different values into a
<code>FlashCard</code>.</p>
<p>We extensively use the <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#field"><code>Decode.field</code></a> decoder. It</p>
<blockquote>
<p>decodes a JSON object, requiring a particular field. The object can have other
fields. Lots of them! The only thing this decoder cares about is if a field is
present and that the value there is an of a certain type. </p>
</blockquote>
<p>Lastly we use <code>Decode.succeed</code> to hard code the face value to be Front.</p>
<h2><a class="header" href="#verification-19" id="verification-19">Verification</a></h2>
<p>We have created a decoder but how do we know that it behaves correctly? We can
write a test to see if our decoder can decode some JSON.</p>
<p>In <code>tests/FlashCardTest.elm</code> write the following code after our other test.</p>
<pre><code class="language-elm">        , test &quot;decode a flash card from JSON&quot; &lt;|
            \_ -&gt;
                let
                    input = &quot;&quot;&quot;{ &quot;front&quot;: &quot;Wettervorhersage&quot;, &quot;back&quot;: &quot;Weather forecast&quot;, &quot;face&quot;: &quot;Back&quot; }&quot;&quot;&quot;

                    expected =
                        flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;
                        |&gt; Ok

                    actual =
                        decodeString FlashCard.decode input
                in
                Expect.equal actual expected
</code></pre>
<p>and all the tests should still work when you import</p>
<pre><code class="language-elm">import Json.Decode exposing (decodeString)
</code></pre>
<h1><a class="header" href="#testing-elm" id="testing-elm">Testing Elm</a></h1>
<p>We would like to send data from the server to the client, interpret the data as
a flash card. There are a lot of things that can go wrong. In order to gain some
confidence that some things are going right, we can write automated tests.</p>
<p>This chapter will setup everything that is needed to start writing tests for our
Elm code.</p>
<h2><a class="header" href="#using-elm-test" id="using-elm-test">Using <code>elm-test</code></a></h2>
<p>We have installed <code>elm-test</code> but we haven't used it yet. Now is a good time. Go
over to the <code>client</code> directory and run the following command</p>
<pre><code class="language-sh">elm-test init
</code></pre>
<p>This will ask to update <code>elm.json</code> with packages that enable us to writing
tests. Agree with the proposed plan. When the command finished there is a new
directory <code>tests</code>.</p>
<pre><code class="language-plain">tests/
└── Example.elm
</code></pre>
<p>We can rename <code>Example.elm</code> to <code>FlashCardTest.elm</code></p>
<h2><a class="header" href="#run-the-test-suite" id="run-the-test-suite">run the test suite</a></h2>
<p>Running the test suite amounts to executing the command</p>
<pre><code class="language-sh">elm-test
</code></pre>
<p>It responds with the following overview</p>
<pre><code class="language-plain">TEST RUN INCOMPLETE because there is 1 TODO remaining

Duration: 253 ms
Passed:   0
Failed:   0
Todo:     1
↓ FlashCardTest
◦ TODO: Implement our first test. See https://package.elm-lang.org/packages/elm-explorations/test/latest for how to do this!
</code></pre>
<p>The reason it reports that there is a TODO is because the generated test file
provided it. Let's change that</p>
<h2><a class="header" href="#write-a-test" id="write-a-test">Write a Test</a></h2>
<p>Replace the <code>todo</code> with the following code</p>
<pre><code class="language-elm">    describe &quot;FlashCard&quot;
        [ test &quot;updating a flash card with a `Flip` message flips the flash card&quot; &lt;|
            \_ -&gt;
                let
                    a_flash_card =
                        flash_card &quot;Wettervorhersage&quot; &quot;Weather forecast&quot;

                    expected =
                        flip a_flash_card

                    actual =
                        update Flip a_flash_card
                in
                Expect.equal actual expected
        ]
</code></pre>
<p>Let's start understanding this from the top. First is the <code>describe</code> function.
It accepts a <code>String</code> that should tell you what is under test and a list of other
tests.</p>
<p>Next we see a <code>test</code> function. It also accepts a <code>String</code> that should tell you
what we are testing. Furthermore, <code>test</code> accepts as it's second argument a
function that can do the actual testing.</p>
<p>In our case the function is a <em>closure</em>, i.e. an anonymous function. In the
function we use a <code>let</code>-expression to set up some variable bindings which we use
to express our expectations. This is achieved with the <code>Expect.equal</code> function.</p>
<p>For this to work we need to import our precious <code>FlashCard</code> functions and types.
We can do this with the following line</p>
<pre><code class="language-elm">import FlashCard exposing (..)
</code></pre>
<h2><a class="header" href="#verification-20" id="verification-20">Verification</a></h2>
<p>We have learned a lot about how a test is written, but does it work? Run the
<code>elm-test</code> command and it should report</p>
<pre><code class="language-plain">TEST RUN PASSED

Duration: 214 ms
Passed:   1
Failed:   0
</code></pre>
<h1><a class="header" href="#model-on-server" id="model-on-server">Model on server</a></h1>
<p>If we want the server to send us a flash card, the server first have to have a
notion of what to send.</p>
<p>In this chapter we our going to model flash cards on the server.</p>
<h2><a class="header" href="#librs" id="librs">lib.rs</a></h2>
<p>The skeletal project generated a <code>main.rs</code>. It would be possible to write all
the necessary code in this file, but that would quickly become unmaintainable.
Rust recognizes this fact and allows for code to write in a library instead.</p>
<p>Create a file <code>lib.rs</code> in the <code>src</code> directory with the following content</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod domain;
#}</code></pre></pre>
<p>The above definition defines a module called <code>domain</code>. Let's go ahead and create it.</p>
<h2><a class="header" href="#domainmodrs" id="domainmodrs">domain/mod.rs</a></h2>
<p>There are various ways to define a module. One way is to create a directory in
the <code>src</code> directory with the same name as the module, in our case <code>domain</code>, and
a file <code>mod.rs</code> in that directory.</p>
<h2><a class="header" href="#struct" id="struct">struct</a></h2>
<p>We would like to focus on modeling flash cards on the server. We have some
experience on the client side. Luckily, that experience translates very well to
the server side.</p>
<p>Rust also knows about records. Rust calls them structs. Take a look at the
following code</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FlashCard {
    front: String,
    back: String,
    face: Face,
}
#}</code></pre></pre>
<p>You probably recognizes a lot from Elm's <code>FlashCard</code>. There are two noteworthy
things two point out.</p>
<p>First the <code>pub</code> keyword. This allows other modules to use this struct. The other
is the <code>Face</code> type. Rust doesn't know about it. So we better define it right
away.</p>
<h2><a class="header" href="#enum" id="enum">enum</a></h2>
<p>Our modeling experience on the Elm side helps us on the Rust side as well.
Again, there is a naming difference, but take a look at <code>Face</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum Face {
    Front,
    Back,
}
#}</code></pre></pre>
<h2><a class="header" href="#constructor" id="constructor">Constructor</a></h2>
<p>When we created our model in Elm, we quickly realized that it becomes tedious to
spell out the structures every time we needed it. To mitigate that we created a
constructor. Let's do the same in Rust.</p>
<p>It looks a bit different, but is similar enough that it is recognizable.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl FlashCard {
    pub fn new&lt;S&gt;(front: S, back: S) -&gt; Self where S: Into&lt;String&gt; {
        Self { front : front.into(), back : back.into(), face : Face::Front }
    }
}
#}</code></pre></pre>
<p>The essence is the following line</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        Self { front : front.into(), back : back.into(), face : Face::Front }
#}</code></pre></pre>
<p>It looks a bit strange with the <code>front.into()</code> and <code>back.into()</code> but that is
because Rust knows different kinds of <a href="https://doc.rust-lang.org/rust-by-example/std/str.html">strings</a>. The input type <code>S : Into&lt;String&gt;</code> allows us to conveniently add any type that knows how to transform
itself into a <code>String</code>.</p>
<h2><a class="header" href="#verification-21" id="verification-21">Verification</a></h2>
<p>We haven't changed our server and only added code. It should still be able to
build our code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
cargo build
#}</code></pre></pre>
<p>The command above should do just that. Other than given some warnings about our
new code not being used, it should compile our code.</p>
<h1><a class="header" href="#serialize-flashcard" id="serialize-flashcard">Serialize FlashCard</a></h1>
<p>We have modeled flash cards on the server. We now need to turn it into JSON
before we can send it to the client.</p>
<p>In this chapter we will use <a href="https://docs.serde.rs/serde/">serde</a> to automatically serialize our flash
cards.</p>
<h2><a class="header" href="#dependency" id="dependency">Dependency</a></h2>
<p>We will need two dependencies that we need to list in our <code>Cargo.toml</code>. Together
they allow us to serialize flash cards into JSON. Add <code>serde</code> and <code>serde_json</code>
to the dependencies table in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">serde = { version = &quot;1.0.101&quot;, features = [ &quot;derive&quot; ] }
sserde_json = &quot;1.0.41&quot;
</code></pre>
<h2><a class="header" href="#use-serde" id="use-serde">Use serde</a></h2>
<p>In order to leverage the serialization capabilities of <code>serde_json</code> we need to
create a <code>serde</code> serializer. There is a very cool trick that <code>serde</code> knows that
makes this a breeze.</p>
<p>The first thing we need to do is to announce we our needing <code>serde</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use serde::Serialize;
#}</code></pre></pre>
<p>The other thing is that we need to tell <code>serde</code> that we would like it to
<em>derive</em> serializers for our data types. We can do this by annotating both
<code>FlashCard</code> and <code>Face</code> with a <code>derive</code> annotation. E.g. <code>Face</code> would be
annotated like</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Serialize)]
pub enum Face {
    Front,
    Back,
}
#}</code></pre></pre>
<h2><a class="header" href="#verification-22" id="verification-22">Verification</a></h2>
<p>With the automatic part of serde done, it is good to see if serialization works
like we expect. The best way to do this is to test is. Rust integrates testing
right at the place where the source is created. Add the following code at the
end of <code>src/domain/mod.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;
    use serde_json;

    #[test]
    fn flash_card_can_be_serialized_to_json() {
        let flash_card = FlashCard::new(&quot;Wettervorhersage&quot;, &quot;Weather forecast&quot;);

        let actual = serde_json::to_string(&amp;flash_card).unwrap();

        let expected = r#&quot;{&quot;front&quot;:&quot;Wettervorhersage&quot;,&quot;back&quot;:&quot;Weather forecast&quot;,&quot;face&quot;:&quot;Front&quot;}&quot;#.to_owned();
        assert_eq!(actual, expected);
    }
}
#}</code></pre></pre>
<p>There is some boilerplate to let the test framework know about what we want to
test. The actual test is</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        let flash_card = FlashCard::new(&quot;Wettervorhersage&quot;, &quot;Weather forecast&quot;);

        let actual = serde_json::to_string(&amp;flash_card).unwrap();

        let expected = r#&quot;{&quot;front&quot;:&quot;Wettervorhersage&quot;,&quot;back&quot;:&quot;Weather forecast&quot;,&quot;face&quot;:&quot;Front&quot;}&quot;#.to_owned();
        assert_eq!(actual, expected);
#}</code></pre></pre>
<p>It creates a <code>FlashCard</code>, serializes it to JSON with <code>serde_json</code>, sets up an
expectation, and checks it the expectation is met.</p>
<p>If you run</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>it should give the all green.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:35174");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
